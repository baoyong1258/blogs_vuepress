(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{173:function(e,n,r){"use strict";r.r(n);var s=r(0),t=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),r("h2",{attrs:{id:"常见-promise-面试题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见-promise-面试题","aria-hidden":"true"}},[e._v("#")]),e._v(" 常见 Promise 面试题")]),e._v(" "),r("p",[e._v("我们看一些 Promise 的常见面试问法，由浅至深。")]),e._v(" "),r("ol",[r("li",[e._v("了解 Promise 吗？")]),e._v(" "),r("li",[e._v("Promise 解决的痛点是什么？")]),e._v(" "),r("li",[e._v("Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。")]),e._v(" "),r("li",[e._v("Promise 如何使用？")]),e._v(" "),r("li",[e._v("Promise 常用的方法有哪些？它们的作用是什么？")]),e._v(" "),r("li",[e._v("Promise 在事件循环中的执行过程是怎样的？")]),e._v(" "),r("li",[e._v("Promise 的业界实现都有哪些？")]),e._v(" "),r("li",[e._v("能不能手写一个 Promise 的 polyfill。")])]),e._v(" "),r("h2",{attrs:{id:"promise的错误处理机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise的错误处理机制","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise的错误处理机制")]),e._v(" "),r("ul",[r("li",[e._v("promise中抛出错误 throw new Error('test') 等同于 reject('test')")]),e._v(" "),r("li",[e._v("Promise 内部的错误不会影响到 Promise 外部的代码")]),e._v(" "),r("li",[e._v("catch方法返回的还是一个 Promise对象，因此后面还可以接着调用then方法")])]),e._v(" "),r("h2",{attrs:{id:"promsie-与事件循环"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promsie-与事件循环","aria-hidden":"true"}},[e._v("#")]),e._v(" Promsie 与事件循环")]),e._v(" "),r("p",[e._v("Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环。")]),e._v(" "),r("h2",{attrs:{id:"promise-简单实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-简单实现","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise 简单实现")]),e._v(" "),r("ul",[r("li",[e._v("promise内部有pending、fulfilled、rejected这三种状态，并且只能从pending到fulfilled/rejected，状态一旦改变无法更改；")]),e._v(" "),r("li",[e._v("内置resolve、reject方法的作用\n"),r("ul",[r("li",[e._v("改变状态")]),e._v(" "),r("li",[e._v("记录value或者reason")]),e._v(" "),r("li",[e._v("触发发布/订阅模式")])])]),e._v(" "),r("li",[e._v("对于then方法的要求\n"),r("ul",[r("li",[e._v("返回一个新的promise用于链式编程")]),e._v(" "),r("li",[e._v("异步执行传入的fufillFn, rejectFn回调函数")]),e._v(" "),r("li",[e._v("如果promise实例对象的状态为pending，则启用发布/订阅模式，将回调函数push")]),e._v(" "),r("li",[e._v("fufillFn回调函数的返回值既可以是普通值也可以是一个promise，当为promise时，这个返回值promise的状态决定了promise.then()这个新promise的状态")])])])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" function isPromise(res) {\n      return (typeof res === 'object' && typeof res.then === 'function') ? true : false;\n    };\n    class myPromise{\n        constructor(cb){\n            this.state = 'pending';\n            this.value = '';\n            this.reason = '';\n            this.resolveCallback = [];\n            this.rejectCallback = [];\n            const resolve = (value) => {\n              if(this.state === 'pending'){\n                  this.value = value;\n                  this.state = 'fufilled';\n                  this.resolveCallback.forEach(fn => fn());\n              }\n            };\n            const reject = (reason) => {\n              if(this.state === 'pending'){\n                  this.reason = reason;\n                  this.state = 'rejected';\n                  this.rejectCallback.forEach(fn => fn());\n              }\n            };\n            cb(resolve, reject);\n        }\n        then(fufillFn, rejectFn){\n            fufillFn = typeof fufillFn === 'function' ? fufillFn : val => val;\n            rejectFn = typeof rejectFn === 'function' ? rejectFn : err => { throw err};\n            let promise2 = new myPromise((resolve, reject) => {\n                // 这里的this代表调用then这个方法的promise实例对象而不是promise2\n                // 以下步骤本质上做两件事：调用fufillFn/rejectFn;改变promise2的状态\n                if(this.state === 'fufilled'){\n                    setTimeout(() => {\n                      let x = fufillFn(this.value);\n                      // 判断x是否为promise再采取相应措施\n                      if(isPromise(x)){\n                        x.then(y => resolve(y), err => reject(err));\n                      }else {\n                        resolve(x);\n                      }\n                    }, 0);\n                }else if(this.state === 'rejected'){\n                    setTimeout(() => {\n                      let x = rejectFn(this.reason);\n                      reject(x);\n                    }, 0);\n                }else if(this.state === 'pending'){\n                    setTimeout(() => {\n                      this.resolveCallback.push(() => {\n                        let x = fufillFn(this.value);\n                        // 判断x是否为promise再采取相应措施\n                        if(isPromise(x)){\n                          x.then(y => resolve(y), err => reject(err));\n                        }else {\n                          resolve(x);\n                        }\n                      });\n                      this.rejectCallback.push(() => {\n                        let x = rejectFn(this.reason);\n                        reject(x);\n                      })\n                    }, 0);\n                }\n            });\n            return promise2;\n        }\n    };\n    myPromise.resolve = function (val) {\n      return new myPromise((resolve, reject) => {\n          resolve(value);\n      })\n    };\n    myPromise.reject = function (reason) {\n      return new myPromise((resolve, reject) => {\n          reject(reason);\n      })\n    };\n    myPromise.race = function (promises) {\n      return new myPromise((resolve, reject) => {\n          for(let i = 0, len = promises.length; i < len; i++){\n              promises[i].then(res => resolve(res), err => reject(err));\n          }\n      })\n    };\n    myPromise.all = function (promises) {\n      let num = 0, len = promises.length, resArr = [];\n      return new myPromise((resolve, reject) => {\n        for(let i = 0; i < len; i++){\n          promises[i].then(res => {\n              resArr[i] = res;\n              num ++;\n              if(num === len){\n                  resolve(resArr);\n              }\n          }, err => reject(err));\n        }\n      })\n    };\n    let p2 = new myPromise((resolve, reject) => {\n        setTimeout(() => {resolve('p2...')}, 1000);\n    });\n    let p3 = new myPromise((resolve, reject) => {\n        setTimeout(() => {resolve('p3...')}, 3000);\n    });\n    let p1 = new myPromise((resolve, reject) => {\n      console.log('entry...');\n      resolve('my promise');\n    });\n    console.log('test resolve...');\n    p1\n      .then(res => {\n        console.log(res);\n        return new myPromise((resolve, reject) => {\n          setTimeout(() => {\n            resolve('then2......')\n          }, 2000);\n        })\n      })\n      .then(res => {\n        console.log(res);\n      });\n    myPromise.all([p2,p3]).then(res => {\n        console.log(res);\n    });\n")])])])])}],!1,null,null,null);n.default=t.exports}}]);